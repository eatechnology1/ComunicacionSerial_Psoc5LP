
/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
*/
#include "project.h"
#include "stdlib.h"
#include "stdio.h"
#include <ssd1306.h>


#define Timer_INTR_MASK_TC           (0x01u)
#define Timer_INTR_MASK_CC_MATCH     (0x02u)



// Definiciones de pines y direcciones I2C
#define AS5600_ADDR                   0x36
#define ANGLE_REG                     0x0E
#define AS5600_CONF_MSB               0x07
#define AS5600_CONF_LSB               0x08

      
//#define REG_RAW_ANGLE_H        0x0C             
//#define REG_ANGLE_H            0x0E        


// Definiciones de pines y direcciones I2C Oled
#define DISPLAY_ADDRESS 0x3C 

// Definiciones de timer
#define UPDATE_PERIOD_MS 15
#define MINUTE_INTERVAL_MS 60000 // 1 minuto en milisegundos
#define DELTA_TIME_CONSTANT 1.7e-5
double long currentTime = 0;
float delta_tiempo;

// Media Movil Delta del angulo
#define MOVING_AVERAGE_WINDOW 100
float deltaAngleHistory[MOVING_AVERAGE_WINDOW]; // Array para almacenar el historial de deltaAngle
int deltaAngleIndex; // Índice para actualizar el array circularmente

// Media Movil Delta del angulo
#define MOVING_AVERAGE_RPM_WINDOW 200
float RPMHistory[MOVING_AVERAGE_RPM_WINDOW]; // Array para almacenar el historial de deltaAngle
int rpmIndex = 0; // Índice para actualizar el array circularmente

///// sumador de pwm
double  long previousMillis = 0; // Variable para almacenar el tiempo del último cambio de pwm
const long interval = 600; // Intervalo de tiempo en milisegundos (1 minuto)
double long prevTime;
double long milliseconds = 0; // Variable para almacenar los milisegundos transcurridos
double AUX = 0; // Variable para almacenar los milisegundos transcurridos


// Variables Globales
uint16_t rawAngle;
uint16_t dutyCycle = 0; // Variable para almacenar el ciclo de trabajo del PWM // valores 0 - 4096
uint16_t pwm = 250; // valores 0 - 4096
float rpm=0;
float pwmup=250;

float anguloGrados;
float angAnterior = 0;
float deltaAngle = 0;

uint32_t elapsedMillis = 0; // Variable para almacenar el tiempo transcurrido

char buffer[500]; // Buffer para convertir los valores a cadena de caracteres

 

// Función para leer el ángulo crudo del sensor AS5600
uint16_t readRawAngle() {
    // Iniciar transmisión I2C al AS5600
    I2C_MasterSendStart(AS5600_ADDR, I2C_WRITE_XFER_MODE);
    I2C_MasterWriteByte(ANGLE_REG);
    I2C_MasterSendStop();  
    // Solicitar 2 bytes del ángulo
    I2C_MasterSendStart(AS5600_ADDR, I2C_READ_XFER_MODE);
    uint8_t msb = I2C_MasterReadByte(I2C_ACK_DATA);
    uint8_t lsb = I2C_MasterReadByte(I2C_NAK_DATA);
    I2C_MasterSendStop();
    rawAngle = (msb << 8) | lsb;
    rawAngle &= 0x0FFF; // Asegurarse de que es un valor de 12 bits
    return rawAngle;
}



CY_ISR(Timer_ISR_Handler) {
     // Incrementa la variable de milisegundos
    currentTime+=UPDATE_PERIOD_MS;
    rawAngle = readRawAngle();// Leer el ángulo crudo y convertir a grados
    delta_tiempo = currentTime - prevTime ; //segundos
    prevTime = currentTime;
    display_clear();  
    anguloGrados =  (rawAngle * 360) / 4096.0; // convertir a grados
    // Calcular la diferencia de ángulo
    if (anguloGrados > angAnterior) {
        deltaAngle = anguloGrados - angAnterior;
    } else if (anguloGrados < angAnterior) {
        deltaAngle = (360 - angAnterior) + anguloGrados;
    }
    angAnterior = anguloGrados;
    ///Media Movil
    deltaAngleHistory[deltaAngleIndex] = deltaAngle;
    deltaAngleIndex = (deltaAngleIndex + 1) % MOVING_AVERAGE_WINDOW;

    // Calcular la media móvil de deltaAngle
    float moving_deltaAngle = 0.0;
    for (int i = 0; i < MOVING_AVERAGE_WINDOW; i++) {
     moving_deltaAngle += deltaAngleHistory[i];
    }
    moving_deltaAngle /= MOVING_AVERAGE_WINDOW;

    // // Almacenar la media móvil en deltaAngle
    deltaAngle = moving_deltaAngle;
//    if (deltaAngle > 5.0){
//            deltaAngle = 0;
//        }
//    ///
    // Calcular RPM    
    double deltaTime = (double)delta_tiempo * DELTA_TIME_CONSTANT; // Convertir a minutos    
     if (deltaTime > 0) {
        float omega = deltaAngle / deltaTime;
        rpm =  omega * (1.0 / 360.0); // pulsos por revolución        
    }
//    ///Media Movil RPM
//    RPMHistory[rpmIndex] = rpm;
//    rpmIndex = (rpmIndex + 1) % MOVING_AVERAGE_RPM_WINDOW;
//    // Calcular la media móvil de rpm
//    float moving_rpm = 0.0;
//    for (int j = 0; j < MOVING_AVERAGE_RPM_WINDOW; j++) {
//     moving_rpm += RPMHistory[j];
//    }
//    moving_rpm /= MOVING_AVERAGE_RPM_WINDOW;
//    rpm = moving_rpm;

    milliseconds++;
    
    //La condición milliseconds > 2000 se cumple aproximadamente cada 2000 * 15 ms, que es 30000 ms (aproximadamente 30 segundos).
    if  (milliseconds>(15000/15)){    
      
      if (pwmup >= 1000) {
        pwm-=250;
        AUX = 0;
        }
    if (pwmup<1000) {
        pwm+=250;  // Aumentar el valor de PWM en 1
        pwmup+=250;
        AUX = 0;
        
      }
       if (pwmup >= 500 && pwm < -0) {
        pwmup = 250;
        pwm = 250;
        } 
    milliseconds = 0;
    ////////////////////////////
    display_clear();    
    gfx_setCursor(40, 0);
    gfx_setTextSize(1);
    gfx_print("READING");
    gfx_setCursor(0,20);
    gfx_print("pwm:   ");
    sprintf(buffer, "%d",pwm);
    gfx_print(buffer);
    display_update();
    ///////////////////////////
    }
//    AUX++;
//    if (AUX>(50000/15)){
//        sprintf(buffer, "%d,  %.2Lf,  %u,  %.5f,  %.3f,  %.2f,  %.6f, \n",
//        dutyCycle, currentTime, rawAngle, anguloGrados, deltaAngle, delta_tiempo, rpm);
          sprintf(buffer, "PWM, %d ,    Time, %.2Lf  ,     Crudo, %u   ,   Grados,   %.5f  , deltaAngle,  %.3f    ,  deltaTime,   %.2f   ,   RPM  ,  %.6f,\n",
          dutyCycle, currentTime, rawAngle, anguloGrados, deltaAngle, delta_tiempo, rpm);
        UART_PutString(buffer);
//    }
    dutyCycle = pwm;
    RPWM_WriteCompare(dutyCycle); 

    
    //Timer1_ReadStatusRegister(); // Clear the interrupt flag
}
void writeRegister16(uint8_t reg, uint16_t value) {
    uint8_t data[3];
    data[0] = reg;
    data[1] = (uint8_t)(value >> 8); // MSB
    data[2] = (uint8_t)(value & 0xFF); // LSB
    
    // Iniciar transmisión I2C
    I2C_MasterSendStart(AS5600_ADDR, I2C_WRITE_XFER_MODE);
    I2C_MasterWriteByte(data[0]);
    I2C_MasterWriteByte(data[1]);
    I2C_MasterWriteByte(data[2]);
    I2C_MasterSendStop();
}

int main(void)
{
    
    /// valores para timer
    CyGlobalIntEnable; /* Habilita las interrupciones globales. */
    // Iniciar la comunicación serial
    UART_Start();
    // Iniciar los PWM
    RPWM_Start();
    LPWM_Start();
    //
    Clock_1_Start();
 
    // Inicializar el puerto I2C y Oled
    I2C_Start();
    display_init(DISPLAY_ADDRESS);
    // Configuración para alta frecuencia de actualización
  uint16_t configValue = 0;
  configValue |= (0b00 << 12); // PM: Nominal (para la mayor tasa de actualización)
  configValue |= (0b00 << 10); // Hysteresis: OFF
  configValue |= (0b00 << 8);  // Output stage: Analog (opcional, cambiar si se usa salida PWM)
  configValue |= (0b00 << 6);  // PWM Frequency: 115 Hz (opcional si se usa salida PWM)
  configValue |= (0b00 << 4);  // Slow filter: 16x (mínimo filtro)
  configValue |= 0b0000;       // Fast filter threshold: No fast filter

  writeRegister16(AS5600_CONF_MSB, configValue);
  UART_PutString("Configuration written for high frequency update!");

    RPWM_WriteCompare(0);
    LPWM_WriteCompare(0);
    // clearing display
    display_clear();    
    display_update();
    gfx_setTextSize(2);
    gfx_setTextColor(WHITE);
    gfx_setCursor(35,22);
    gfx_println("READ");
    display_update();    
    CyDelay(10000);
    // Escribir encabezado solo una vez
    UART_PutString("\r\nPWM, , Crudo, , Grados,  delta, deltaAngle\r\n");
    display_clear();    
    gfx_setCursor(40, 0);
    gfx_setTextSize(1);
    gfx_print("READING");
    gfx_setCursor(0,20);
    gfx_print("pwm:   ");
    sprintf(buffer, "%d",pwm);
    gfx_print(buffer);
    display_update();
       // Configurar el temporizador
    Timer1_Start();
    isr_StartEx(Timer_ISR_Handler); // Configurar ISR para el temporizador
    
    
    
    while (1) { 
            
    }
}

/* [] END OF FILE */
